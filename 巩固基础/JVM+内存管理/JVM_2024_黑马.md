# JVM_黑马

## 基础篇

### 初识JVM

1. JVM是什么？

   JVM是Java虚拟机。

2. JVM功能？

   - 解释和运行：对字节码文件中的指令，实时的解释为机器码，让计算机执行
   - 内存管理：自动为对象、方法等分配内存；自动的垃圾回收机制，回收不再使用的对象
   - 即时编译：对热点代码进行优化，将解释的机器码缓存在内存中，下次运行的时候直接取出执行。

3. 常见JVM

   - HotSpot
   - GrallVM
   - Dragonwell JDK
   - J9

### 字节码文件详解

1. JVM组成部分
   - 类加载器（ClassLoader）
   - 运行时数据区域（JVM管理的内存）
   - 执行引擎（即时编译器、解释器、垃圾回收器等）
   - 本地接口（本地已经编译的方法）
2. 字节码文件的组成
   - 基础信息：魔数、字节码文件对应的Java版本号、访问表示（public 、final等）父类和接口
   - 常量池：保存了字符串常量、类或接口名、字段名主要在字节码指令中使用
   - 字段：当前类或接口声明的字段信息
   - 方法：当前类或接口声明的方法信息，字节码指令
   - JVM内存区域

**基础信息**

**魔数：**因为文件不能通过扩展名来确定文件的类型（文件后缀名可以随意的更改，不影响文件的内容），响应能够打开文件的软件会使用文件的头几个字节（文件头）去检验文件的类型，如果魔数不匹配，那么就表示当前软件不支持该种类型，那么就会报错。

**主版本号：**表示jdk的大版本，1.2之后的主版本号的计算方式就是主版本号-44。

**常量池**

作用：避免相同的内容重复定义，节省空间。

常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速找到对应的数据。字节码指令中通过编号引用到常量池的过程称之为**符号引用**。

**方法**

```branch
iconst_0:将0放到操作数栈中
istore_1：将操作数栈中的数字移动到局部变量表数组下标为1的位置
iload_1：将局部变量数组下标为1位置上的数字复制一份放到操作数栈中
iinc 1 by 1:在局部变量表1号位置上直接增加1
```

```Java
    int i = 0,j=0,k=0;

    i++;

    j = j + 1;

    k += 1;

/*    0 iconst_0
    1 istore_1
    2 iconst_0
    3 istore_2
    4 iconst_0
    5 istore_3

    -----------------
    i++
    6 iinc 1 by 1 局部变量表1号位置直接增加1

    -----------------
    j = j + 1
    9 iload_2
    10 iconst_1
    11 iadd
    12 istore_2

    -----------------


    k += 1
    13 iinc 3 by 1
    16 return*/

    //从字节码分析，i++和k+=1都是使用的字节码指令iinc 局部变量表中的位置 by 需要直接加上的值 所以二者的运行效率是一致的
    //j = j + 1使用的是指令iload_2 iconst_1 iadd istore_2，所以运行效率较低
```

**字节码常用工具**

- Javap -v命令：是jdk自带的反编译工具，可以通过控制台查看字节码文件。

- jclasslib

- arthas

  - 监控面板

  - 查看字节码信息

  - 方法监控

  - 类的热部署

  - 内存监控

  - 垃圾回收监控

  - 应用热点定位

    **常用命令：**

    ```branch
    启动：java -jar arthas-boot.jar
    将当前字节码文件保存到指定路径:dump -d 指定路径 包名/类名
    将class文件反编译 ：jad 包名.类名
    ```

**类加载器**

- 类的生命周期
  1. 加载
     - **类加载器**根据类的权限名通过不同渠道以二进制流的方式获取字节码文件。
     - 类加载器在加载完类之后，java虚拟机会将字节码中的信息保存到方法区中。
     - 方法区中生成一个InstanceKlass对象，保存类的所有信息，里面还包含实现特定功能比如多态的信息。
     - Java虚拟机还会再堆中生成一份与方法区中数据类似的java.lang.Class对象。作用是在java代码中去获取类的信息以及存储静态字段的数据。
     
  2. 连接
  
     - 验证：验证字节码文件的内容是否满足《Java虚拟机规范》，程序员一般不参与
     - 准备：给静态变量赋初始值，如果是final修饰的基本数据类型的静态变量，那么就会在该阶段直接赋值并不会先赋值初始值。
     - 解析：将常量池中的符号引用替换成指向内存的直接引用
  
  3. 初始化
  
     - 初始化阶段会执行静态代码块中的代码，并为静态变量赋值。
  
       ```bash
       putstatic 将操作数栈中的值放入所对应的静态变量值中
       ```
  
     - 初始化**<clint>**方法中的执行顺序和java中编写的顺序是一致的。
  
     - 导致类初始化的方式
  
       - 访问一个类的静态变量或静态方法，如果变量是final修饰的并且等号右边是常量不会触发初始化。
  
       - 调用Class.forName(String className)
  
       - new一个该类的对象时
  
       - 执行main方法的当前类
  
       - 子类初始化方法调用之前，会先调用父类的初始化方法。
  
       - final修饰的变量如果变量赋值的内容需要执行指令才能得出结果，那么也会执行初始化方法。
  
         ```java
         public class Foundation3 {
             public static void main(String[] args) {
                 new Test2();
             }
         
         }
         class Test2{
             public final static int a = Integer.valueOf("1");
             static {
                 System.out.println("Test2 初始化了~~");
             }
         }
         ```
  
         
  
     - 不会触发初始化的情况
  
       - 无静态代码块且无静态变量赋值语句。
       - 有静态变量的声明，但是没有复制语句。
       - 静态变量的定义被final修饰
       - 直接访问父类的静态变量，不会触发子类的初始化。
       - 数组的创建不会导致数组中元素的类进行初始化。
  
  4. 使用
  
  5. 卸载
  
- **类加载器**（JDK9之前）

  1. 类加载器：是虚拟机提供给应用程序去实现获取类和接口字节码数据的技术。

  2. 类加载器：只参与加载过程中的字节码获取并加载到内存这一部分。

  3. 类加载器的分类

     - Java代码中实现
       - 继承自抽象类ClassLoader，所有实现的类加载器都需要继承这个类
       - jdk8和以前：启动类（加载核心类）、扩展类（Java中比较通用的类）、应用程序类（加载应用使用的类）
     - Java虚拟机底层源码实现（c语言或者c++语言）：加载程序运行时的基础类，确保可靠性

  4. 启动类加载器

     默认加载Java安装目录/jre/lib下的类文件。

     可以使用参数：-Xbootclasspath/a:jar包目录/jar包名进行扩展，让启动类加载器加载用户所创建的内容。

     ```bash
     -Xbootclasspath/a:jar包目录/jar包名
     ```

  5. 扩展类加载器

     默认加载Java安装目录/jre/lib/ext下的类文件。

     是JDK中提供的，使用Java语言编写的类加载器。

     追加类加载器所加载的内容：

     ```bash
     -Djava.ext.dirs=原本所加载jar包目录;追加的jar包目录
     ```

     不同的操作系统中，追加的符号不同：Windows（;），Mac/linux（:）

  6. 应用程序加载器

     加载classpath下的类文件。

     包含：自己书写的类文件和第三方提供的jar包

**双亲委派机制**

核心是解决**一个类到底由哪个类加载器来进行加载。**

1. 双亲委派机制的作用

   - 保证类加载的安全性，可以避免恶意的替换JDK中核心类库，确保核心类库的完整性与安全性。
   - 避免重复的加载，就是可以避免一个类被多次的进行加载。

2. 双亲委派机制

   指的是：当一个类加载器接收到加载类的任务时，会自底而上查找是否加载过，再由顶向下进行加载。

   - 查找的顺序：应用程序类加载器->扩展类加载器->启动类加载器

     向上查找时如果已经加载过，就直接返回Class对象，加载过程结束。这样就可以避免一个类被多次的加载。

   - 尝试加载的顺序:启动类加载器->扩展类加载器->应用程序类加载器

     如果上级加载器无法加载该类，那么上级加载器就会将加载任务传递给下级。所以看上去才会是从上而下的尝试加载。这样的加载过程，体现了加载的优先级。

3. 打破双亲委派机制

   - 自定义类加载器

     - Tomcat使用自定义类加载器来实现应用之间类的隔离。
     - 如果在自定义的类加载器中不指定父类加载器，那么默认父类就是应用程序加载器
     - 两个自定义的类加载器加载相同类限名不会冲突，在同一个Java虚拟机中，只有相同的类加载器+相同的类限名才会被认为是同一个类。
     - 重写loadClass方法，将双亲委派机制的代码去除就可以打破双亲委派机制。
     - 正确的去实现一个自定义类加载器的方式是重写findClass方法，这样才不会打破双亲委派机制。

   - 线程上下文类加载器

     - JDBC案例

       - SPI机制：是JDK内置的一种服务提供发现机制。

       - Spi工作原理：

         1. 在claspath路劲下的META-INF/service文件夹中，以接口的全限定名来命名文件名，对应的文化里面写接口的实现。

         2. 使用ServiceLoader加载实现类。

            ```Java
            //获取上下文 类加载器(应用程序加载器)
            ClassLoader cl = Thread.currentThread().getContextClassLoader();
            ```

4. 热部署类的思路（应急的手段，不会改变jar包中的内容，程序重启之后修改的错误会恢复）

   1. 在出现问题的服务器上部署arthas，启动。
   2. jad --source-only 类全限名 > 目录/文件名.java；将出现问题的类通过反编译成Java源码，通过vim等操作进行修改。
   3. mc -c 类加载器的hashcode 目录/文件吗.java -d 输出目录;mc 命令用来编译修改过后的代码
   4. retransform  class 文件所在目录/xxx.class；用retransform 命令加载新的字节码。这样就可以对类进行热部署。

**类加载器（JDK8以后）**

- 启动类加载器使用Java编写，位于ClassLoaders类中；继承自BuiltinClassLoader实现从模块中找到要加载的字节码资源文件。启动类加载器依旧无法通过Java代码获取。
- 扩展类加载器被替换成了平台类加载器（Platform Class Loader），平台类加载器存在更多的是为了老版本的设计方案兼容，自身没有特殊的逻辑。

**运行时数据区**

Java虚拟机在运行Java程序过程中管理的内存区域，称之为运行时数据区。

- 线程不共享：每一个线程单独维护，不会出现线程安全问题；包含：程序计时器，Java虚拟机线。本地方法栈。
- 线程共享：多个线程都可以进行访问，存在线程安全的问题；包含：方法区、堆。

组成：

1. 程序计时器：PC寄存器，每一个线程会通过程序计时器记录当前要执行的字节码指令地址。
   - 可以控制程序指令的进行，实现分支、跳转、异常等逻辑。
   - 多线程的情况下，Java虚拟机需要通过程序计时器记录CPU切换前解释到那一句指令并继续解释运行。
   - 程序计时器不会出现内存溢出。
   
2. 栈：包含：Java虚拟机栈、本地方法栈（c++）；Java虚拟机栈：采用栈的数据结构来管理方法调用的基本情况，先进后出，每一个方法的调用使用一个栈帧来保存。
   - Java虚拟机栈随着线程的创建而创建，而回收则是会在线程销毁时进行。由于方法可能会在不同的线程中执行，所以每个线程都会包含一个自己的虚拟机栈。
   
   - 栈帧的组成：局部变量表、操作树栈、帧数据。
     
     - 局部变量表：作用就是在方法的执行过程中存放所有的局部变量。在栈帧中局部变量表是一个**数组**，数组每一个位置称为槽，long和double类型占用**两个**槽位，其他类型的占用一个槽位。在实例方法中，序号为0的局部变量表中的位置存放的是调用当前方法的对象（**this**），运行时存放的就是当前实例对象的地址。为了节省空间，局部变量表中的槽是可以复用的。一旦某个局部变量不再生效，当前槽就可以进行复用。
     - 操作数栈：是虚拟机在执行命令过程中用来存放中间数据的一块区域。如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。**在编译期**就可以确定操作数栈的最大深度，从而在执行正确的分配内存大小。
     - 帧数据：
       1. 动态链接：当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系。
       2. 方法出口：是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的下一条指令地址。所以当前栈帧中，需要存储此方法出口的地址。
       3. 异常表：存放的是代码中异常处理信息，包含了异常捕获的生效范围以及异常发生后跳转到的字节码指令位置。
     
   - 栈内存溢出：栈中的栈帧如果数量多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出。如果不指定栈的大小，JVM将创建一个 具有默认大小的栈，大小取决于操作系统和 计算机体系 结构。HotSport对栈的大小的最大值和最小值有要求：最大不能超过1024M（Windows下），最小不能 小于180K（Windows下）。局部变量过多、操作数栈深度过大也会影响栈内存的大小。一般情况下此参数可以手动的设定为-Xss256K节省空间。
   
     ```bash
     -Xss栈大小 后续需要追加单位，K M G
     ```
   
3. 堆：创建出来的对象都存在于堆上。栈上的局部变量表中，可以存放堆上对象的引用。静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。

   - 堆内存溢出：堆内存是有上限的，当一直创建对象并放到堆内存中，就会达到上限抛出异常。默认的最大内存：7G。随着堆内存不足，Java虚拟机就会不断的分配内存，total值会变大，total最多只能与max相等。

   - 三个需要关注的参数：used tottal max

     - used：指的是当前已经使用的堆内存
     - total：是Java虚拟机已经分配的可用堆内存
     - max：是Java虚拟机可以 分配的最大堆内存

   - 如果不设置堆内存的大小，max默认是系统内存的1/4,total默认的是系统的1/64。在实际的应用中一般要 设置total和max的值。

     ```bash
     设置最大可分配堆内存：-Xmx值
     设置初始的total值：-Xms值
     限制：Xmx必须大于 2MB ，Xms必须大 1MB
     ```

   - **建议将-Xmx和-Xms设置为相同的值**，这样可以减少Java虚拟机在申请并分配堆内存上的时间上的开销。

4. 方法区：是存放基础信息的位置，线程共享，主要包含三部分内容：类的元信息、运行是常量池、字符串常量池。JDK8之后，方法区存放在元空间中，元空间位于操作系统维护的直接内存中，默认情况下只要不超过操作系统的承受上限，可以一直分配。

   ```bash
   将元空间的大小进行限制：-XX:MaxMetaspaceSize=值，一般设置为256MB
   ```

   

   - 类的元信息：保存了所有类的基本信息。
   - 运行时常量池：字节码文件中通过编号查表的方式找到常量，这种常量池被称为静态常量池。当常量池加载到内存中之后，可以通过内存地址快速定位到常量池中的内容，这种常量池称为运行时常量池。
   - 字符串常量池：在代码中定义的常量字符串。 JDK7以及以后的版本，字符串常量池在堆上，所以如果将堆上的内容使用intern方法放到 常量池中，那么常量池中存放的就是该数值在堆上的地址。

5. 直接内存

   ```bash
   手动设置直接内存的大小：-XX：MaxDirectMemorySize=大小
   ```

   - Java堆中的对象如果不再使用要回收，回收时会影响对象的创建和使用。可以用直接内存来进行解决。
   - IO操作比如读文件，需要先把文件读入直接内存（缓冲区）再把数据复制到Java堆中。现在直接放入直接内存中即可，同时Java在堆上的维护直接内存的引用，减少了数据复制的开销。写文件也是类似的。

### JVM垃圾回收

```bash
查看垃圾回收的信息
-verbose:gc
```

- **自动垃圾回收（GC）**：通过自动垃圾回收机制，使用垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责对堆上的内容进行回收。

  - 解决系统僵死的问题：出现了频繁的垃圾回收。
  - 性能优化：进行合理的设置可以有效地提升程序的执行性能。

- **方法区回收：**线程不共享的部分，都是伴随着线程的创建而创建，线程的销毁而销毁。方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。方法区回收的内容主要是**不再使用的类**。需要手动的触发垃圾回收，可以调用System.gc()方法，但是该方法不是立刻进行垃圾回收，而是向虚拟机发送请求，具体还需要由虚拟机进行判断。

  - 不再使用的类的判定方法：
    - **此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。**
    - 加载该类的类加载器已经被回收。
    - 该类对应的java.lang.class对象没有在任何地方被引用。
    - 在java程序中，如果是自己写的类会被应用程序类加载器加载，但是该类加载器不会被回收，那么自己手写的类在java虚拟机中不会被回收。如果手动的创建手写类的类加载器也可以手动的将类加载器回收。

- **堆回收：**Java中对象是否能被回收，是根据对象是否被引用来决定的。如果对象被引用，说明该类还在使用不允许回收。

  - 引用计数法：会为每一个对象维护一个引用计数器，当对象被引用时+1，取消引用-1.
    - 优点：简单容易实现。
    - 缺点：1.每次引用和取消引用都需要维护计数器，对系统的性能有一定的影响；2.存在循环引用的问题，A引用B，B引用A是会出现对象无法回收的问题。
  - 可达性分析算法：可达性分析将对象分为两类(垃圾回收的根对象GC Root 和普通对象)，对象与对象之间存在引用关系。可达性分析算法指的是如果从某个GC Rott对象是可达的，对象就不可被回收。
    - 能够被称为GC Root对象的对象有：
      - **线程Thread对象，引用线程栈帧中的方法参数，局部变量等。**
      - 系统类加载器加载的java.lang.class对象，引用类中的静态变量
      - 监视器对象，用来保存同步锁synchronized关键字持有对象。
      - 本地方法调用时使用的全局对象。
  - 对象引用：可达性算法中描述的对象引用，一般指的是强引用，即GC Root对象对普通对象有引用关系。
    - 软引用
      - 如果一个对象只有软引用关联到他，当程序内存不足时，就会将软引用中的数据进行回收。
      - JDK1.2版之后提供了SoftReference类实现软引用，软引用常用于缓存中。
    - 弱引用
      - 
    - 虚引用
      - 
    - 终结期引用
      - 

  ​		

  