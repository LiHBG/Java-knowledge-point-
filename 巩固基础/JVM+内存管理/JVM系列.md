# JVM系列

## JVM概述：

#### HotSpot VM：

**类装载器子系统--运行时数据区--执行引擎**

<img src="C:\Users\李洪斌\AppData\Roaming\Typora\typora-user-images\image-20250324112630096.png" alt="image-20250324112630096" style="zoom:50%;" />

**Java的执行流程：**

| 1.Java源文件，通过Java编译器生成JVM能够运行的Java字节码文件  |      |
| :----------------------------------------------------------- | ---- |
| **2.Java字节码文件，通过JVM虚拟机，汇编成操作系统能够执行的机器指令** |      |

### JVM架构模式

**Java编译器输入的指令基本是一种基于栈的指令集架构。**

### JVM的生命周期

#### 启动：

**是通过引导类加载器（bootstrap class loader）创建的一个初始类（initial class）来完成的，这个类是由虚拟机的具体实现指定的。**

#### 虚拟机执行：

- **一个运行中的Java虚拟机有着一个清晰的任务：执行Java程序**
- **程序开始的时候JVM虚拟机才运行，程序结束的时候它就结束**
- **执行一个所谓的Java程序的时候，真真正正是在执行一个叫做Java虚拟机的进程。程序结束，进程也会结束。**

#### 虚拟机的退出：

**以下几种情况：**

- **程序正常执行结束**
- **程序在执行的过程中遇到了异常或错误而异常终止**
- **由于操作系统出现错误而导致Java虚拟机进程终止**
- **某一个线程调用了Runtime类的halt方法或者System类的exit方法，并且Java安全管理器允许本次方法的执行**

### JVM发展的历史

#### Sun Classic VM

- **第一款商用Java虚拟机**
- **本款虚拟机内部只提供了解释器，执行的效率比较的低下**
- **现在hotspot VM内置了本款虚拟机**

#### Exact VM

- **可以知道内存中某个位置的数据具体是什么类型**
- **编译器与解释器混合工作模式**
- **可以探测热点代码，编译器可以将热点代码编译成机器码缓存起来重复执行**

#### HotSpot VM

-  **服务器、桌面移动端、嵌入式都有应用。**
- **通过计数器找到最具编译价值代码，触发即时编译或栈上替换**
- **通过编译器与解释器协同工作，在最优化的程序响应时间与最佳执行性能中取得平衡**

#### JRockit

- **专注于服务器应用**
- **不太关注程序启动速度，所以虚拟机内部不包含解释器实现，全部代码都靠即时编译器编译后执行。**
- **MissionControl服务套件，是一组以极低的开销来监控、管理和分析生产环境之中的应用程序工具。**

#### J9

- **与hotpost的应用场景接近**

#### Graal VM

- **在HotSpot VM基础上增强而成的跨语言全栈虚拟机，可以作为“任何语言”的平台使用。**
- **支持不同语言中混用对方接口和对象，支持这些语言使用已经编写好的本地库文件**
- **工作原理是将这些语言的源代码或源代码编译之后的中间格式，通过解释器转换为能被Graal VM接受的中间表示。Graal VM提供Truffle工具集快速进行构建而向一种新语言的解释器。在运行时还能进行即时编译优化，获得比原生编译器更优秀的执行效率。**

## 类加载器：

### 类加载器子系统作用：

- **类加载器子系统只负责从文件系统或网络中加载class文件，class文件在开头有特定的文件标识。**
- **ClassLoder只负责Class文件的加载，关于它是否能够运行，则是由执行引擎决定。**
- **加载类信息存放于一块称为方法区的内存空间。除了类信息外，方法区中还会存放运行时常量池信息。可能还包含字符串字面量和数字常量（这部分常量信息是class文件中常量池部分的内存映射）**

### 类的加载过程：

- **加载：**

  1. 通过类的全限名获取定义此类的二进制字节流。
  2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
  3. 在内存中生成一个代表这个类的Java.lang.class对象，作为方法区这个类的各种数据的访问入口。

- **Linking：**

  1. 验证：

     - 目的在于确保Class文件的字节流中包含信息符合当前虚拟机要求，保证被类加载的正确性，不会危害虚拟机自身的安全。
     - 主要包含四种验证，文件格式验证；元数据验证；字节码验证；符号引用验证。

  2. 准备：

     - 为类变量分配内存并且设置该类变量的默认初始值。

       ```Java
       public class JvmClassLoder {
           private static int a = 10;
           // 在类加载的过程中的Linking阶段的准备阶段，a的值是默认的初始化的值，也就是0。
           public static void main(String[] args) {
               System.out.println(a);
           }
       }
       ```

       

     - **这里不包含使用final修饰的static，因为final在编译的时候就会分配了，准备阶段会显示初始化。**

     - **这里不会为实例变量分配初始化，**类变量会分配在方法区中，而实例变量是会随着对象一起分配到Java堆中。

  3. 解析：

     - 将常量池内的符号引用转换为直接引用的过程。
     - 事实上，解析操作往往会伴随着JVM在执行完初始化之后再执行。
     - 主要针对类或接口、字段、类方法、接口方法、方法类型等。

- **初始化：**

  1. 初始化阶段就是执行**类构造器方法<clinit>()**的过程

  2. **类构造器方法<clinit>()**不同于类的构造器，类构造器在虚拟机中的表现是**<init>()**。

  3. **类构造器方法<clinit>()**不需要定义，是javac编译器自动收集类中所有类变量的赋值动作和静态代码块中的语句合并而来。

     ```Java
     public class JvmClassLoader2 {
     
         private static int number = 10;
     
         static {
             number = 20;
             number2 = 40;
         }
         
         private static int number2 = 30;
     
         public static void main(String[] args) {
             //  number值的变化过程：
             //          1.首先是在类的加载过程中，会经历阶段Linking，其中会对类的变量进行初始化赋值，赋值的内容就是初始化值。
             //          2.在类的加载过程中，会经历初始化过程，这个时候会按照从上到下的顺序对类的静态变量进行赋值。
             //          linking:o ----> initializing: 10 -> 20
             System.out.println(number);// 20
             // number2值的变化过程：
             //          1.首先是在类的加载过程中，会经历阶段Linking，其中会对类的变量进行初始化赋值，赋值的内容就是初始化值。
             //          2.在类的加载过程中，会经历初始化过程，这个时候会按照从上到下的顺序对类的静态变量进行赋值。
             //           linking:o ----> initializing: 40 -> 30
             System.out.println(number2);// 30
         }
     }
     ```

  4. 如果该类存在父类，那么虚拟机会保证子类的**<clinit>()方法**执行前，父类的**<clinit>()方法**已经执行完毕。

  5. 虚拟机必须保证一个类的**<clinit>()方法**在多线程下被同步加锁。

### 类加载器的分类：

- 引导类加载器：负责加载Java的核心类库
- 自定义加载器：一般指的是程序开发人员自定义的一类的类加载，但是Java虚拟机规范没有这么定义，而是**将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器**。